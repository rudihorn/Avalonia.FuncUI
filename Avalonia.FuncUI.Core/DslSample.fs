namespace Avalonia.FuncUI.Core.DslSample

open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.Patterns

open Avalonia.Controls
open Avalonia.Media

module rec FuncUI =

    (* Content of a View Element *)
    type ViewContent = 
    | None
    | Single of IViewElement
    | Multiple of IViewElement list


    type Update<'t when 't :> IControl> = 't -> unit
    type Create<'t when 't :> IControl> = unit -> 't

    type IViewElement = 
        abstract member Create: unit -> IControl
        abstract member Update: IControl -> unit
        abstract member Content: ViewContent with get

    type ViewElement<'t when 't :> IControl>(create: Create<'t>, update: Update<'t>, content: ViewContent) = 
        let targetType = typeof<'t>
        let create = create
        let update = update
        let content = content

        interface IViewElement with
            member __.Create () = create() :> IControl
            member __.Update ref = update (ref :?> 't)
            member __.Content with get () = content

    (* HACK *)
    // Type safe Attributes are the ultimate goal
    // the problems with them currently are
    // - Type providers cant generate DUs
    // - Classic one time code generation only works for compile time known controls

    let any<'R> : 'R = failwith "!"

    type IAttr<'t> =
        abstract member Apply: 't -> unit

    type Attr<'t, 'v>(expr: Expr, value: 'v) = 
        let expr = expr
        let value = value

        interface IAttr<'t> with
            member __.Apply (target: 't): unit =
                match expr with
                | PropertyGet (_, propInfo, _) ->
                    propInfo.SetValue(target, value)
                | _ -> failwith "Not a Property"
                ()


    (* Should later be generated by the type provider for each control *)

    let createBtn (args: IAttr<Button> list) (content: IViewElement): IViewElement =
        let create: Create<Button> = fun () -> Button()
        let update: Update<Button> = fun btn -> btn.Tag <- args
        ViewElement(create, update, ViewContent.Single content) :> IViewElement

    let createTextBlock (args: IAttr<TextBlock> list): IViewElement=
        let create: Create<TextBlock> = fun () -> TextBlock()
        let update: Update<TextBlock> = fun c -> c.Tag <- args
        ViewElement(create, update, ViewContent.None) :> IViewElement

    let createStackPanel (args: IAttr<StackPanel> list) (items: IViewElement list): IViewElement =
        let create: Create<StackPanel> = fun () -> StackPanel()
        let update: Update<StackPanel> = fun c -> c.Tag <- args
        ViewElement(create, update, ViewContent.Multiple items) :> IViewElement

    let view () =
        let view =
            createStackPanel [] [
                createTextBlock [ Attr(<@ any<TextBlock>.Text @>, "Test") ]
                createStackPanel [] [
                    createBtn [
                        // Should be cleaner with DUs
                        Attr(<@ any<Button>.Width @>, 100.0)
                        Attr(<@ any<Button>.Height @>, 100.0)
                        Attr(<@ any<Button>.Background @>, SolidColorBrush(Colors.Red))
                    ] (createTextBlock [ Attr(<@ any<TextBlock>.Text @>, "Test") ])
                    createBtn [
                        Attr(<@ any<Button>.Width @>, 100.0)
                        Attr(<@ any<Button>.Height @>, 100.0)
                    ] (createTextBlock [ Attr(<@ any<TextBlock>.Text @>, "Test") ])
                ]
            ]
        ()